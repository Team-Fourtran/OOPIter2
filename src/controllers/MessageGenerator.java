package controllers;

import sun.plugin2.message.Message;
import tests.AssetIterator;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;

class MessageGenerator implements KeyPressListener{
    private ArrayList<Mode> modes = new ArrayList<Mode>();
    private Mode currentMode;
    private int modeIndex;	//Originally used ListIterator, but the Java List interface iterators are garbage

    protected AssetIterator assetIterator;

    private KeyboardController receiver;

    MessageGenerator(KeyboardController receiver, KeyPressInformer keyInformer, AssetIterator assIter){
        initializeModes();
        this.assetIterator = assIter;
        this.receiver = receiver;
        //System.out.println(this.modes);
        keyInformer.registerClient(this);
    }
    //Gets called when player turn switches. Changes the iterator on hand.
    protected void updateIterator(AssetIterator assetIterator){
        this.assetIterator = assetIterator;
    }

    @Override //Listen to notifications from a KeyPressInformer
    public void updateKeysPressed(HashMap<String, Boolean> kp) {
        interpretKeystrokes(kp);
    }

    private void interpretKeystrokes(HashMap<String, Boolean> keystrokes){
        //System.out.println(keystrokes);
        if(keystrokes.get("ENTER")){
            generateMessage();
        }

        if(keystrokes.get("CONTROL")){
            //Cycle MODE
            if(keystrokes.get("UP")){
                nextMode();
            } else if(keystrokes.get("DOWN")){
                previousMode();
            }

            //Cycle TYPE
            else if(keystrokes.get("LEFT")){
                this.currentMode.controlLeft();			//Forward to Mode
            } else if(keystrokes.get("RIGHT")){
                this.currentMode.controlRight();		//Forward to Mode
            }

        } else {
            if(keystrokes.get("UP")){
                this.currentMode.upKey();          		//Forward to Mode
            } else if(keystrokes.get("DOWN")){
                this.currentMode.downKey();		    	//Forward to Mode
            }

            //Cycle TYPE
            else if(keystrokes.get("LEFT")){
                this.currentMode.leftKey(); 			//Forward to Mode
            } else if(keystrokes.get("RIGHT")){
                this.currentMode.rightKey();    		//Forward to Mode
            }
        }
    }

    private void generateMessage(){
        //Sends receiver a message as generated by the current Mode
        receiver.handleMsg(this.currentMode.generateMessage());
    }

    private void initializeModes(){
        //Fill this.modes with the 4 modes
        this.modes.add((Mode) new RallyPointMode(this));
        this.modes.add((Mode) new StructureMode(this));
        this.modes.add((Mode) new UnitMode(this));
        this.modes.add((Mode) new ArmyMode(this));

        //Initialize currentMode
        this.modeIndex = 0;
        this.currentMode = (Mode) this.modes.get(modeIndex);
    }

    //Switches the mode to the next mode on the list, looping back around when the end is reached.
    private void nextMode(){
        this.modeIndex = Utils.mod(this.modeIndex + 1,this.modes.size());
        this.currentMode = (Mode) modes.get(modeIndex);
        System.out.println(currentMode);
    }

    //Switches the mode to the previous mode on the list, looping back around when the beginning is reached.
    private void previousMode(){
        this.modeIndex = Utils.mod(this.modeIndex - 1,this.modes.size());
        this.currentMode = (Mode) modes.get(modeIndex);
        System.out.println(currentMode);

    }
}

interface Mode{
    String generateMessage();


    void controlLeft();
    void controlRight();


    void upKey();
    void downKey();

    void leftKey();
    void rightKey();

    String toString();
}

class UnitMode implements Mode{
    MessageGenerator parent;

    UnitMode(MessageGenerator msgGen){
        parent = msgGen;
    }

    @Override
    public String generateMessage() {
        return null;
    }

    public void controlLeft() {

    }

    public void controlRight() {

    }

    @Override
    public void upKey() {

    }

    @Override
    public void downKey() {

    }

    @Override
    public void leftKey() {

    }

    @Override
    public void rightKey() {

    }
}

class StructureMode implements Mode{
    MessageGenerator parent;

    StructureMode(MessageGenerator msgGen){
        parent = msgGen;
    }

    @Override
    public String generateMessage() {
        return null;
    }

    @Override
    public void controlLeft() {


    }

    @Override
    public void controlRight() {

    }

    @Override
    public void upKey() {

    }

    @Override
    public void downKey() {

    }

    @Override
    public void leftKey() {

    }

    @Override
    public void rightKey() {

    }
}

class RallyPointMode implements Mode{
    MessageGenerator parent;

    RallyPointMode(MessageGenerator msgGen){
        parent = msgGen;
    }

    @Override
    public String generateMessage() {
        return null;
    }

    @Override
    public void controlLeft() { }

    @Override
    public void controlRight() { }

    @Override
    public void upKey() {

    }

    @Override
    public void downKey() {

    }

    @Override
    public void leftKey() {

    }

    @Override
    public void rightKey() {

    }
}

class ArmyMode implements Mode{
    MessageGenerator parent;

    ArmyMode(MessageGenerator msgGen){
        parent = msgGen;
    }

    @Override
    public String generateMessage() {
        return null;
    }

    @Override
    public void controlLeft() {

    }

    @Override
    public void controlRight() {

    }

    @Override
    public void upKey() {

    }

    @Override
    public void downKey() {

    }

    @Override
    public void leftKey() {

    }

    @Override
    public void rightKey() {

    }
}

//Custom operations to deal with some quirks
class Utils{
    //Different interpretation of mod for negative numbers.
    //Necessary for circular iteration through modes/types etc.
    public static int mod(int i, int n){
        return (i >= 0) ? (i%n) : (n+i);
    }
}